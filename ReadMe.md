# Counterexamples of Overfitted Programs

The overfitted programs and their test cases can be found in the `NotVerified` folder. Specifically, you will find a split of `Overfitting` and `JMLFalseNegative` programs. `Overfitting` programs are __subdivided by the APR tool__ which generated the patch. `JMLFalseNegative` programs are first __subdivided by categories__ `Modular`, `Overflow`, and `Structural`; which then are __subdivided by APR tool__. The APR tools' subdirectories contains each of the __incorrectly verfied programs__ for each bug introduced. Please see below for an example:

```text
NotVerified/
├── JMLFalseNegatives          
│   ├── Modular                
│   │   └── ArjaE              
│   │       ├── Alphabet       
│   │       │   └── bug34
│   │       │       ├── Bug
│   │       │       │   ├── Alphabet.java
│   │       │       │   └── esc.txt
│   │       │       └── Repaired 
│   │       │           ├── Alphabet.java (Repaired Buggy Program)
│   │       │           ├── AlphabetTest.java (Counterexamples test cases)
│   │       │           ├── ESC_Repaired.txt
│   │       │           ├── ReadMe.txt
│   │       │           └── counterexamples.txt (Counterexamples)
│   ...
├── Overfitting
│   ├── ArjaE
│   │   ├── Alphabet
│   │   │   ├── bug1
│   │   │   │   ├── Bug
│   │   │   │   │   ├── Alphabet.java
│   │   │   │   │   └── esc.txt
│   │   │   │   └── Repaired
│   │   │   │       ├── Alphabet.java (Repaired Buggy Program)
│   │   │   │       ├── AlphabetTest.java (Counterexamples test cases)
│   │   │   │       ├── ESC_Repaired.txt
│   │   │   │       ├── ReadMe.txt
│   │   │   │       └── counterexamples.txt (Counterexamples)
...
```

 Each individual bug includes the __original buggy program__ in `Bug`. The `Repaired` directory contains the APR tool's __repaired program__, __OpenJML's counterexamples__, and manually generated __test cases__. Each of the counterexamples and their associated test cases are provided for a double-blind conference. You can find one unverified program and its counterexample [here](NotVerified/Overfitting/ArjaE/Alphabet/bug1/Repaired), and the original program [here](NotVerified/Overfitting/ArjaE/Alphabet/bug1/Bug).

# BuggyJava+JML

The BuggyJava+JML dataset has 597 buggy programs, and each program has one bug. This dataset is created based on the [Java+JML dataset](https://github.com/Amirfarhad-Nilizadeh/Java-JML) by using [PITest](https://pitest.org/). PITest generates bugs by changing control conditions, changing assignment expressions, removing a method call, and changing return values. Only two bugs in this dataset are real bugs (from [QuixBug](https://github.com/jkoppel/QuixBugs)) that we add JML specification to their correct versions. 

Each buggy program has a formal specification in JML that describes the correct behavior of the program. Also, [OpenJML](http://www.openjml.org/) does verify the correctness of the correct versions of these programs. We used OpenJML 8.46 for this study, and you can find warnings besides each buggy program with the name "esc.txt" in the dataset. 

Among the 597 buggy programs, 40 have a bug that is not be detected with the JUnitTests dataset, and 10 of them go to an infinite loop during testing. Thus, for our APR study, we used 547 buggy programs.

# JUnitTests

JUnitTests were generated by running [Kelinci](https://github.com/isstac/kelinci) (the Java version of AFL fuzzer) 5 times on each program in the Java+JML dataset (correct version of programs) to cover all normal branch behavior. This test does not cover branches that are terminated by throwing an exception. Kelinci provides tests by covering all branches (other than these exceptional behaviors) in each run. Thus, each branch is covered at least 5 individual tests.

# NotVerified

Repaired programs cannot be verified with OpenJML for two main reasons.

1) The repaired program is overfitted. It means the repaired program is not correct based on the correct version of the programs' expected behavior, but it satisfies the test suite, which is provided with JUnitTests.  

2) It is a JML False Negative. It is possible that JML specification mistakenly considers a correct repaired program as overfitted. This happened for only about 4.15% of generated patches. We classified these false negatives into three classes: 1) Structural 2) Modularity 3) Overflow.

# TimeComplexityOrder

Our results show that the order of time complexity can change and increase dramatically by using current dynamic APR tools. It happened for seven repaired programs in our study. Increasing the order of time complexity is not a test overfitting problem in theory because the expected behavior is still correct. However, it could be a significant issue in practice by changing the program's character (changing binary search to a linear search).

# Usage

These dataset were created for the following paper. Cite this paper if you use these programs in any academic research.

@inproceedings{aprFormalMethods,
  title={Exploring True Test Overfitting in Dynamic Automated Program Repair using Formal Methods (in press)},
  author={Amirfarhad Nilizadeh and Gary T. Leavens and Xuan-Bach Le and Corina S. Pasareanu and David Cok},
  booktitle={2021 14th IEEE Conference on Software Testing, Validation and Verification (ICST)},
  year={2021},
  organization={IEEE}
}



